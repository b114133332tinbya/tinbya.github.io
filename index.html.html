<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Time Swamp – Tense Quiz</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      max-width: 700px;
      margin: 40px auto;
      padding: 0 16px;
      line-height: 1.6;
    }
    h1 {
      text-align: center;
      margin-bottom: 4px;
    }
    .subtitle {
      text-align: center;
      font-size: 0.9rem;
      color: #555;
      margin-top: 0;
      margin-bottom: 24px;
    }
    #question-box {
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 16px 20px;
      margin-bottom: 16px;
      background: #f9f9f9;
    }
    #question-text {
      font-weight: 600;
      margin-bottom: 12px;
      white-space: pre-line; /* 讓 \n 換行 */
    }
    .option {
      margin: 6px 0;
    }
    button {
      padding: 8px 16px;
      margin-top: 8px;
      border-radius: 6px;
      border: 1px solid #888;
      cursor: pointer;
      font-size: 0.95rem;
    }
    button:disabled {
      cursor: not-allowed;
      opacity: 0.6;
    }
    #feedback {
      margin-top: 10px;
      font-weight: 600;
    }
    .correct {
      color: #1a7f1a;
    }
    .wrong {
      color: #c0392b;
    }
    #explanation {
      margin-top: 6px;
      font-size: 0.95rem;
      color: #333;
      white-space: pre-line;
    }
    #status {
      font-size: 0.85rem;
      color: #555;
      margin-bottom: 8px;
    }
    #text-answer {
      width: 100%;
      max-width: 100%;
      padding: 6px 8px;
      margin-top: 4px;
      box-sizing: border-box;
    }
    #input-label {
      margin-top: 4px;
      font-size: 0.95rem;
    }
  </style>
</head>
<body>
  <h1>Time Swamp – Tense Quiz</h1>
  <p class="subtitle">每次掃 QR / 重新進入，都會拿到一題不同的「時態」題目。</p>

  <div id="status"></div>

  <div id="question-box">
    <div id="question-text">Loading question...</div>

    <form id="options-form"></form>

    <div id="input-label"></div>
    <input id="text-answer" type="text" style="display:none;" placeholder="Type your answer here">

    <div id="feedback"></div>
    <div id="explanation"></div>
  </div>

  <button id="check-btn">Check Answer</button>

  <script>
    // ===== 題庫設定：10 題，對應你給的 10 個題型 =====
    // type: "mcq" = 選擇題, "input" = 填空 / 改寫 / 單字題
    const questions = [
      // 1. Present Simple（判斷題）
      {
        type: "mcq",
        text:
"The swamp spirits ___ messages to players who step on the glowing tiles.\n(Choose the best form.)",
        options: ["send", "sends", "are sending"],
        correctIndex: 0,
        explanation: "主詞 spirits 為複數，所以用原形動詞 send（第三人稱複數）。"
      },
      // 2. Present Continuous（情境圖題 → 選答案）
      {
        type: "mcq",
        text:
"You are walking in the swamp and see this:\n\"The wooden paths are shaking and the Time Tree is losing its light.\"\nWhich sentence best describes what is happening right now?",
        options: [
          "The swamp shakes every night.",
          "The wooden paths are shaking at this moment.",
          "The tree lost its light yesterday."
        ],
        correctIndex: 1,
        explanation: "題目強調『現在正在發生』，所以用現在進行式 are shaking at this moment。"
      },
      // 3. Present Perfect（閱讀理解）
      {
        type: "mcq",
        text:
"Reading:\n\"The guardians have crossed five dangerous zones, but they still haven’t reached the Magic Fruit.\nThe spirits have warned them several times, yet the players keep moving deeper into the forest.\"\nQuestion: What does \"haven’t reached\" show?",
        options: [
          "They reached the fruit long ago.",
          "They are now holding the fruit.",
          "They still haven't reached the fruit up to now."
        ],
        correctIndex: 2,
        explanation: "現在完成式 haven't reached 表示到現在為止『還沒有到達』，所以是 C。"
      },
      // 4. Present Perfect Continuous（情境填空）
      {
        type: "input",
        text:
"The swamp fog ___ (rise) for hours, and now the paths are almost invisible.\nFill in the correct verb form:",
        answer: "has been rising",
        explanation: "for hours + 現在仍有影響，表示『到現在持續了一段時間』，用現在完成進行式 has been rising。"
      },
      // 5. Past Simple（改寫句）
      {
        type: "input",
        text:
"Rewrite the sentence in the past simple:\nOriginal: The guardians see a whirlpool beside the broken log.",
        answer: "The guardians saw a whirlpool beside the broken log.",
        explanation: "see 的過去式是 saw，整句改為過去簡單式：The guardians saw a whirlpool beside the broken log."
      },
      // 6. Past Continuous（推論題）
      {
        type: "mcq",
        text:
"Reading:\n\"While the players were building a new road tile, a crocodile suddenly appeared.\"\nQuestion: What were the players doing when the crocodile appeared?",
        options: [
          "They built the road earlier.",
          "They were building a road tile.",
          "They will build the road later."
        ],
        correctIndex: 1,
        explanation: "while + 過去進行式 were building，表示當鱷魚出現時，他們『正在鋪路』。"
      },
      // 7. Past Perfect（錯誤偵測 → 單字修正）
      {
        type: "input",
        text:
"Error spotting:\n\"Before the spirits arrived, the swamp had already change its shape.\"\nWhat is the correct form of \"change\"?",
        answer: "changed",
        explanation: "過去完成式 had + p.p.，所以 change 要改為過去分詞 changed。"
      },
      // 8. Past Perfect Continuous（高難度閱讀 + 填空）
      {
        type: "input",
        text:
"Reading:\n\"The Time Tree had been glowing for centuries before the swamp began to collapse.\"\nFill in the blank:\nThe Time Tree ___ (glow) for a long time before the collapse started.",
        answer: "had been glowing",
        explanation: "for a long time + before + 過去動作，表示『在那之前已經持續一段時間』，用過去完成進行式 had been glowing。"
      },
      // 9. Future Simple（條件推論）
      {
        type: "input",
        text:
"If you step on a cursed tile, the spirits ___ (remove) one of your road pieces.\nFill in the correct verb form:",
        answer: "will remove",
        explanation: "第一類條件句：If + 現在簡單式（step），主句用未來簡單式 will remove。"
      },
      // 10. Future Perfect / Future Continuous（理解題）
      {
        type: "mcq",
        text:
"Reading:\n\"By the time you reach the Time Tree, the other players will have built more than ten road tiles.\"\nWhich sentence is TRUE?",
        options: [
          "The players built the tiles long ago.",
          "The players are building tiles right now.",
          "The players will have completed more than ten tiles before you arrive."
        ],
        correctIndex: 2,
        explanation: "will have built 是未來完成式，表示『在你到達之前就已經完成超過十塊路』，所以 C 正確。"
      }
    ];

    const questionTextEl = document.getElementById("question-text");
    const optionsFormEl = document.getElementById("options-form");
    const feedbackEl = document.getElementById("feedback");
    const explanationEl = document.getElementById("explanation");
    const checkBtn = document.getElementById("check-btn");
    const statusEl = document.getElementById("status");
    const textAnswerEl = document.getElementById("text-answer");
    const inputLabelEl = document.getElementById("input-label");

    let currentQuestion = null;
    let currentIndex = null;
    let hasAnswered = false;

    // 從 localStorage 讀取已出過的題目 index
    function loadUsedIndexes() {
      try {
        const raw = localStorage.getItem("time_swamp_used_indexes_v2");
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        if (Array.isArray(parsed)) return parsed;
        return [];
      } catch (e) {
        return [];
      }
    }

    // 寫回 localStorage
    function saveUsedIndexes(arr) {
      localStorage.setItem("time_swamp_used_indexes_v2", JSON.stringify(arr));
    }

    // 挑一題「沒出過」的 index；如果都出完，就清空紀錄重新開始
    function pickQuestionIndex() {
      let used = loadUsedIndexes();
      if (used.length >= questions.length) {
        used = [];
      }
      const available = [];
      for (let i = 0; i < questions.length; i++) {
        if (!used.includes(i)) {
          available.push(i);
        }
      }
      const randomPos = Math.floor(Math.random() * available.length);
      const chosenIndex = available[randomPos];

      used.push(chosenIndex);
      saveUsedIndexes(used);

      statusEl.textContent =
        `This device has seen ${used.length} / ${questions.length} questions. （本裝置已抽過 ${used.length} 題）`;

      return chosenIndex;
    }

    function loadQuestion() {
      feedbackEl.textContent = "";
      feedbackEl.className = "";
      explanationEl.textContent = "";
      hasAnswered = false;

      currentIndex = pickQuestionIndex();
      currentQuestion = questions[currentIndex];

      questionTextEl.textContent = currentQuestion.text;

      // 重置 UI
      optionsFormEl.innerHTML = "";
      textAnswerEl.value = "";
      textAnswerEl.style.display = "none";
      inputLabelEl.textContent = "";

      if (currentQuestion.type === "mcq") {
        // 顯示選項
        currentQuestion.options.forEach((opt, idx) => {
          const div = document.createElement("div");
          div.className = "option";

          const input = document.createElement("input");
          input.type = "radio";
          input.name = "option";
          input.value = idx;
          input.id = "opt" + idx;

          const label = document.createElement("label");
          label.htmlFor = "opt" + idx;
          label.textContent = opt;

          div.appendChild(input);
          div.appendChild(label);
          optionsFormEl.appendChild(div);
        });
      } else if (currentQuestion.type === "input") {
        // 顯示填空框
        inputLabelEl.textContent = "Type your answer here:";
        textAnswerEl.style.display = "block";
      }
    }

    function normalize(str) {
      return str.trim().toLowerCase().replace(/\s+/g, " ");
    }

    function checkAnswer() {
      if (!currentQuestion || hasAnswered) return;

      if (currentQuestion.type === "mcq") {
        const selected = document.querySelector('input[name="option"]:checked');
        if (!selected) {
          feedbackEl.textContent = "Please choose an answer first. 請先選一個選項。";
          feedbackEl.className = "wrong";
          return;
        }
        const selectedIndex = parseInt(selected.value, 10);
        const isCorrect = selectedIndex === currentQuestion.correctIndex;
        hasAnswered = true;

        if (isCorrect) {
          feedbackEl.textContent = "Correct! ✓";
          feedbackEl.className = "correct";
        } else {
          feedbackEl.textContent = "Wrong ✗";
          feedbackEl.className = "wrong";
        }

        const correctText = currentQuestion.options[currentQuestion.correctIndex];
        explanationEl.textContent =
          `Correct answer: "${correctText}".\n說明：` + currentQuestion.explanation;

      } else if (currentQuestion.type === "input") {
        const userAns = normalize(textAnswerEl.value);
        if (!userAns) {
          feedbackEl.textContent = "Please type your answer first. 請先輸入答案。";
          feedbackEl.className = "wrong";
          return;
        }
        const correctAns = normalize(currentQuestion.answer);
        hasAnswered = true;

        if (userAns === correctAns) {
          feedbackEl.textContent = "Correct! ✓";
          feedbackEl.className = "correct";
        } else {
          feedbackEl.textContent = "Not exactly. ✗";
          feedbackEl.className = "wrong";
        }

        explanationEl.textContent =
          `Suggested answer: "${currentQuestion.answer}".\n說明：` + currentQuestion.explanation;
      }
    }

    checkBtn.addEventListener("click", checkAnswer);

    // 初始載入
    loadQuestion();
  </script>
</body>
</html>
